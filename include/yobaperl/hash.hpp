#ifndef YOBAPERL_HASH_HPP
#define YOBAPERL_HASH_HPP

#include "yobaperl/common.hpp"
#include "yobaperl/variable.hpp"
#include "yobaperl/hash_iterator.hpp"

namespace yoba {



////////////////////////////////////////////////////////////
/// \brief %Hash reference
///
/// \cpp
/// Hash hash = perl.newHash<IV>({ { "a", 1 }, { "b", 2} }); // (my) %hash = (a => 1, b => 2)
/// hash.insert("c", perl.newScalar(3));                     // $hash{c} = 3
/// Scalar a = hash.get("a").makeCopy();                     // $a = $hash{a}
/// \endcpp
///
////////////////////////////////////////////////////////////
class YOBAPERL_EXPORT Hash : public Variable
{
   friend class HashIterator;

public:
   using Iterator = HashIterator; ///< Type alias
   


   ////////////////////////////////////////////////////////////
   /// \brief Constructor
   ///
   /// Use Perl::newHash() instead
   ///
   ////////////////////////////////////////////////////////////
   Hash(Perl & perl, HV * hv, bool increase_refcount);
   


   /// @{ \name Hash elements

   ////////////////////////////////////////////////////////////
   /// \brief Add element
   ///
   /// \perl $hash{key} = $scalar \endperl
   ///
   ////////////////////////////////////////////////////////////
   Hash & insert(const std::string & key, const Scalar & value);
   Hash & insert(const std::pair<std::string, Scalar> & pair);
   Hash & insert(const std::unordered_map<std::string, Scalar> & hashmap);

   ////////////////////////////////////////////////////////////
   /// \brief Fetch element
   ///
   /// \perl $scalar = $hash{key} \endperl
   ///
   /// \exception PerlException Element not exists
   ///
   ////////////////////////////////////////////////////////////
   Scalar get(const std::string & key);

   ////////////////////////////////////////////////////////////
   /// \brief Remove element and return
   ///
   /// \perl $scalar = delete $hash{key} \endperl
   ///
   /// \exception PerlException Element not exists
   ///
   ////////////////////////////////////////////////////////////
   Scalar remove(const std::string & key);

   ////////////////////////////////////////////////////////////
   /// \brief Remove all elements
   ///
   /// \perl %hash = () \endperl
   ///
   ////////////////////////////////////////////////////////////
   Hash & clear();

   /// @}



   /// @{ \name Misc

   ////////////////////////////////////////////////////////////
   /// \brief Elements count
   ///
   /// \perl scalar keys %hash \endperl
   ///
   ////////////////////////////////////////////////////////////
   I32 getSize() const;

   ////////////////////////////////////////////////////////////
   /// \brief Check if hash is empty
   ///
   /// \perl scalar keys %hash \endperl
   ///
   ////////////////////////////////////////////////////////////
   bool isEmpty() const;

   ////////////////////////////////////////////////////////////
   /// \brief Check element exists
   ///
   /// \perl exists $hash{key} \endperl
   ///
   ////////////////////////////////////////////////////////////
   bool isExists(const std::string & key) const;

   ////////////////////////////////////////////////////////////
   /// \brief Convert to C++ string
   ///
   ////////////////////////////////////////////////////////////
   std::string toString() const;

   ////////////////////////////////////////////////////////////
   /// \brief Convert to C++ hash map
   ///
   ////////////////////////////////////////////////////////////
   std::unordered_map<std::string, Scalar> toMap() const;

   ////////////////////////////////////////////////////////////
   /// \brief Take reference
   ///
   /// \perl $ref = \%hash \endperl
   ///
   ////////////////////////////////////////////////////////////
   Scalar makeRef() const;

   ////////////////////////////////////////////////////////////
   /// \brief Copy each element to new hash
   ///
   /// \perl %copy = %hash \endperl
   ///
   /// \see Scalar::makeCopy()
   ///
   ////////////////////////////////////////////////////////////
   Hash makeCopy() const;

   ////////////////////////////////////////////////////////////
   /// \brief Forward iterator
   ///
   ////////////////////////////////////////////////////////////
   Iterator begin() const;
   Iterator end() const;
   
   /// @}



   /// @{ \name Internals

   ////////////////////////////////////////////////////////////
   /// \brief Raw hash
   ///
   ////////////////////////////////////////////////////////////
   HV * getHV() const;

   /// @}



   /// @{ \name Operators

   ////////////////////////////////////////////////////////////
   /// \brief Unsafe version of get()
   ///
   ////////////////////////////////////////////////////////////
   Scalar operator[] (const std::string & key) noexcept;
   Scalar operator[] (const char * key) noexcept;

   ////////////////////////////////////////////////////////////
   /// \brief Alias to ! isEmpty()
   ///
   ////////////////////////////////////////////////////////////
   operator bool() const;

   /// @}



protected:
   void _store(const std::string & key, SV * value);

private:
   I32  _interInit() const;
   HE * _interNext() const;
};



} // namespace yoba

#endif // YOBAPERL_HASH_HPP
