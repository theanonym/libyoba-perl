#ifndef YOBAPERL_VARIABLE_HPP
#define YOBAPERL_VARIABLE_HPP

#include "yobaperl/common.hpp"

namespace yoba {

class Perl;
class Scalar;
class Array;
class Hash;
class Code;



////////////////////////////////////////////////////////////
/// \brief Base class for perl variables
///
////////////////////////////////////////////////////////////
class YOBAPERL_EXPORT Variable
{
public:



   ////////////////////////////////////////////////////////////
   /// \brief Constructor
   ///
   ////////////////////////////////////////////////////////////
   Variable(Perl & perl, SV * sv, bool increase_refcount);

   ////////////////////////////////////////////////////////////
   /// \brief Copy constructor
   ///
   /// \note Increases SV reference count
   ///
   ////////////////////////////////////////////////////////////
   Variable(const Variable & to_copy);

   ////////////////////////////////////////////////////////////
   /// \brief Move constructor
   ///
   /// Reference count not affected
   ///
   ////////////////////////////////////////////////////////////
   Variable(Variable && to_move);

   ////////////////////////////////////////////////////////////
   /// \brief Destructor
   ///
   /// \note Decreases SV reference count
   ///
   ////////////////////////////////////////////////////////////
   virtual ~Variable();



   /// @{ \name Misc

   ////////////////////////////////////////////////////////////
   /// \brief Convert to C++ string
   ///
   ////////////////////////////////////////////////////////////
   virtual std::string toString() const = 0;

   ////////////////////////////////////////////////////////////
   /// \brief Add/remove readonly flag
   ///
   ////////////////////////////////////////////////////////////
   void setReadOnly(bool state);

   ////////////////////////////////////////////////////////////
   /// \brief Check if SV has readonly flag
   ///
   ////////////////////////////////////////////////////////////
   bool isReadOnly() const;

   ////////////////////////////////////////////////////////////
   /// \brief Get Perl instance
   ///
   ////////////////////////////////////////////////////////////
   Perl & getPerl() const;

   /// @}



   /// @{ \name Internals

   ////////////////////////////////////////////////////////////
   /// \brief Get raw scalar
   ///
   ////////////////////////////////////////////////////////////
   SV * getSV() const;

   ////////////////////////////////////////////////////////////
   /// \brief Nullify object and return SV
   ///
   /// Reference count not affected
   ///
   ////////////////////////////////////////////////////////////
   SV * detachSV();

   ////////////////////////////////////////////////////////////
   /// \brief Nullify object and return mortalized SV
   ///
   /// Reference count not affected
   ///
   ////////////////////////////////////////////////////////////
   SV * detachMortalSV();

   ////////////////////////////////////////////////////////////
   /// \brief Get SV reference count
   ///
   ////////////////////////////////////////////////////////////
   U32 getRefcount() const;

   ////////////////////////////////////////////////////////////
   /// \brief Increase SV reference count
   ///
   ////////////////////////////////////////////////////////////
   void increaseRefcount();

   ////////////////////////////////////////////////////////////
   /// \brief Decrease SV reference count
   ///
   ////////////////////////////////////////////////////////////
   void decreaseRefcount();

   ////////////////////////////////////////////////////////////
   /// \brief Dump SV data to stderr
   ///
   ////////////////////////////////////////////////////////////
   void dump() const;

   /// @}



   /// @{ \name Operators

   ////////////////////////////////////////////////////////////
   /// \brief Compare SV pointers
   ///
   ////////////////////////////////////////////////////////////
   bool operator== (const Variable & other);
   bool operator!= (const Variable & other);

   ////////////////////////////////////////////////////////////
   /// \brief Operator for streams
   ///
   /// Calls virtual toString()
   ///
   ////////////////////////////////////////////////////////////
   friend std::ostream & operator<< (std::ostream & stream, const Variable & var);

   /// @}



protected:
   Perl & _perl;
   PerlInterpreter * _interpreter = nullptr;
   SV * _sv = nullptr; // Can be SV, AV, HV, CV
};



} // namespace yoba

#endif // YOBAPERL_VARIABLE_HPP
