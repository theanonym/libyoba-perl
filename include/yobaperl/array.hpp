#ifndef YOBAPERL_ARRAY_HPP
#define YOBAPERL_ARRAY_HPP

#include "yobaperl/common.hpp"
#include "yobaperl/variable.hpp"
#include "yobaperl/array_iterator.hpp"

namespace yoba {



//TODO av_delete
//TODO av_fill
////////////////////////////////////////////////////////////
/// \brief %Array reference
///
/// \cpp
/// Array array = perl.newArray({ 1, 2, 3 }); // (my) @array = (1, 2, 3)
/// array.unshift(perl.newScalar(0));         // unshift @array, 0
/// array.push(perl.newScalar(4));            // push @array, 4
/// Scalar second = array.get(1).makeCopy();  // $second = $array[1]
/// Array copy = array.makeCopy();            // @copy = @array
/// \endcpp
///
////////////////////////////////////////////////////////////
class YOBAPERL_EXPORT Array : public Variable
{
public:
   using Iterator = class ArrayIterator; ///< Type alias



   ////////////////////////////////////////////////////////////
   /// \brief Constructor
   ///
   /// Use Perl::newArray() instead
   ///
   ////////////////////////////////////////////////////////////
   Array(Perl & perl, AV * av, bool increase_refcount);



   /// @{ \name Array elements

   ////////////////////////////////////////////////////////////
   /// \brief Fetch element by index
   ///
   /// \perl $scalar = $array[index] \endperl
   ///
   /// \note Scalar not copied, use get(index).makeCopy()
   ///
   /// \exception PerlException Bound check failure
   ///
   ////////////////////////////////////////////////////////////
   Scalar get(const SSize_t index) const;

   ////////////////////////////////////////////////////////////
   /// \brief Get first element
   ///
   /// \perl $scalar = $array[0] \endperl
   ///
   /// \note Scalar not copied, use getFirst().makeCopy()
   ///
   /// \exception PerlException Bound check failure
   ///
   ////////////////////////////////////////////////////////////
   Scalar getFirst() const;

   ////////////////////////////////////////////////////////////
   /// \brief Get last element
   ///
   /// \perl $scalar = $array[-1] \endperl
   ///
   /// \note Scalar not copied, use getLast().makeCopy()
   ///
   /// \exception PerlException Bound check failure
   ///
   ////////////////////////////////////////////////////////////
   Scalar getLast() const;

   ////////////////////////////////////////////////////////////
   /// \brief Replace element
   ///
   /// \perl $array[index] = $scalar \endperl
   ///
   /// \note Scalar not copied, use replace(index, scalar.makeCopy())
   ///
   /// \exception PerlException Bound check failure
   ///
   ////////////////////////////////////////////////////////////
   Array & replace(const SSize_t index, const Scalar & scalar);

   ////////////////////////////////////////////////////////////
   /// \brief Add element to end
   ///
   /// \perl push @array, $scalar \endperl
   ///
   /// \note Scalar not copied, use push(scalar.makeCopy())
   ///
   ////////////////////////////////////////////////////////////
   Array & push(const Scalar & scalar);

   ////////////////////////////////////////////////////////////
   /// \brief Add other array to end
   ///
   /// \perl push @array, @other \endperl
   ///
   /// \note Elements not copied, use push(array.makeCopy())
   ///
   ////////////////////////////////////////////////////////////
   Array & push(const Array & array);
   Array & push(const std::vector<Scalar> & scalars);
   Array & push(const std::list<Scalar> & scalars);

   ////////////////////////////////////////////////////////////
   /// \brief Add element to begin
   ///
   /// \perl unshift @array, $scalar \endperl
   ///
   /// \note Scalar not copied, use unshift(scalar.makeCopy())
   ///
   ////////////////////////////////////////////////////////////
   Array & unshift(const Scalar & scalar);

   ////////////////////////////////////////////////////////////
   /// \brief Add other array to begin
   ///
   /// \perl unshift @array, @other \endperl
   ///
   /// \note Elements not copied, use unshift(array.makeCopy())
   ///
   ////////////////////////////////////////////////////////////
   Array & unshift(const Array & array);
   Array & unshift(const std::vector<Scalar> & scalars);
   Array & unshift(const std::list<Scalar> & scalars);

   ////////////////////////////////////////////////////////////
   /// \brief Remove last element and return
   ///
   /// \perl $scalar = pop @array \endperl
   ///
   /// \note Scalar not copied, use pop().makeCopy()
   ///
   /// \exception PerlException Bound check failure
   ///
   ////////////////////////////////////////////////////////////
   Scalar pop();

   ////////////////////////////////////////////////////////////
   /// \brief Remove first element and return
   ///
   /// \perl $scalar = pop @array \endperl
   ///
   /// \note Scalar not copied, use shift().makeCopy()
   ///
   /// \exception PerlException Bound check failure
   ///
   ////////////////////////////////////////////////////////////
   Scalar shift();

   ////////////////////////////////////////////////////////////
   /// \brief Remove all elements
   ///
   /// \perl @array = () \endperl
   ///
   ////////////////////////////////////////////////////////////
   Array & clear();

   /// @}



   /// @{ \name Misc

   ////////////////////////////////////////////////////////////
   /// \brief Elements count
   ///
   /// \perl scalar @array \endperl
   ///
   ////////////////////////////////////////////////////////////
   int getSize() const;

   ////////////////////////////////////////////////////////////
   /// \brief Check if array is empty
   ///
   /// \perl !@array \endperl
   ///
   ////////////////////////////////////////////////////////////
   bool isEmpty() const;

   ////////////////////////////////////////////////////////////
   /// \brief Check element exists
   ///
   /// \perl exists $array[index] \endperl
   ///
   ////////////////////////////////////////////////////////////
   bool isExists(SSize_t index) const;

   ////////////////////////////////////////////////////////////
   /// \brief Reserve space
   ///
   ////////////////////////////////////////////////////////////
   Array & reserve(SSize_t size);

   ////////////////////////////////////////////////////////////
   /// \brief Copy each element to new array
   ///
   /// \perl @copy = @array \endperl
   ///
   /// \see Scalar::makeCopy()
   ///
   ////////////////////////////////////////////////////////////
   Array makeCopy() const;

   ////////////////////////////////////////////////////////////
   /// \brief Take reference
   ///
   /// \perl $ref = \@array \endperl
   ///
   ////////////////////////////////////////////////////////////
   Scalar makeRef() const;

   ////////////////////////////////////////////////////////////
   /// \brief Convert to C++ string
   ///
   ////////////////////////////////////////////////////////////
   std::string toString() const;

   ////////////////////////////////////////////////////////////
   /// \brief Convert to C++ vector
   ///
   ////////////////////////////////////////////////////////////
   std::vector<Scalar> toVector() const;

   ////////////////////////////////////////////////////////////
   /// \brief Convert to C++ list
   ///
   ////////////////////////////////////////////////////////////
   std::list<Scalar> toList() const;

   ////////////////////////////////////////////////////////////
   /// \brief Iterator to first element
   ///
   ////////////////////////////////////////////////////////////
   Iterator begin() const;

   ////////////////////////////////////////////////////////////
   /// \brief Iterator to last element + 1
   ///
   ////////////////////////////////////////////////////////////
   Iterator end() const;

   /// @}



   /// @{ \name Internals

   ////////////////////////////////////////////////////////////
   /// \brief Get raw array
   ///
   ////////////////////////////////////////////////////////////
   AV * getAV() const;

   /// @}



   /// @{ \name Operators

   ////////////////////////////////////////////////////////////
   /// \brief Unsafe version of get()
   ///
   ////////////////////////////////////////////////////////////
   Scalar operator[] (const SSize_t index) const noexcept;

   ////////////////////////////////////////////////////////////
   /// \brief Alias to push()
   ///
   ////////////////////////////////////////////////////////////
   Array & operator+= (const Scalar & scalar);

   ////////////////////////////////////////////////////////////
   /// \brief Alias to push()
   ///
   ////////////////////////////////////////////////////////////
   Array & operator<< (const Scalar & scalar);

   ////////////////////////////////////////////////////////////
   /// \brief Merge two arrays
   ///
   /// \perl @array = (@array1, @array2) \endperl
   ///
   /// \note Elements not copied, use array1.makeCopy() + array2.makeCopy()
   ///
   ////////////////////////////////////////////////////////////
   Array operator+ (const Array & other) const;

   ////////////////////////////////////////////////////////////
   /// \brief Alias to ! isEmpty()
   ///
   ////////////////////////////////////////////////////////////
   operator bool() const;

   /// @}



protected:
   void _store(const int index, Scalar scalar);
   void _push(Scalar scalar);

   bool _checkIndex(const SSize_t index) const;

   SV ** _getFirstSV() const;
   SV ** _getLastSV() const;
};



} // namespace yoba

#endif // YOBAPERL_ARRAY_HPP
